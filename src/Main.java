import java.sql.Array;
import java.util.*;


public class Main {

    static public class ListNode {
        int val;
        ListNode next;
        ListNode(int x) { val = x; }
    }

    static   public class TreeNode {
          int val;
          TreeNode left;
          TreeNode right;
          TreeNode(int x) { val = x; }
      }


    public static void main(String[] args) {
        maximumGap test = new maximumGap();
//        String[] t = {"practice", "makes", "perfect", "coding", "makes"};
        int[] t = {92,30851,24320,20449,7333,29396,10949,17319,9810,21985,29425,28393,4598,29346,1811,10903,20728,20667,18348,21336,9544,15695,17833,3454,23749,24144,8316,1724,2592,26682,13576,31104,19172,23553,13245,31362,11956,24903,25092,17565,9172,4307,2781,30431,3308,17215,25286,30940,25608,14320,25312,31047,3810,10316,24397,15043,18532,6950,23772,8950,17257,3197,27112,16351,27332,15719,32381,14186,25219,16456,10173,21826,11893,5447,642,10983,8681,27395,18757,30208,31929,22401,31039,16626,22919,7530,21197,29105,20807,20851,14617,15063,30717,29724,13559,8947,5832,21405,7949,5667,18208,18973,13623,13797,21340,11302,7978,23338,119,31574,9815,32428,9491,12631,9490,31618,12734,14097,28915,24561,3701,23581,17532,16518,29030,25213,27645,16737,4858,29323,14773,18900,25363,2864,1338,5677,9107,16982,14875,7119,3101,27040,14787,29576,23327,27480,5280,15902,30736,29609,24197,14123,2806,14862,8781,27179,11564,32522,14530,15828,5986,4634,1725,18854,28901,29672,26254,10690,9249,26817,16541,17663,23652,3913,5970,14651,4324,20333,2611,25071,16644,13722,5196,11526,17875,3628,2516,12784,23765,21802,6413,16114,20487,20016,21100,20672,24349,22700,31738,10317,19982,21581,13306,29410,15570,10681,9932,14446,11370,19327,23569,1053,21794,17228,24336,31531,12819,8033,18009,22011,26091,21572,24231,28515,23793,26294,32011,24138,20547,29158,15431,19830,3682,24036,10616,1439,11505,23128,9209,24008,1978,29044,29827,1487,12530,18215,24473,24386,14014,22676,14115,22644,25078,20418,12121,32208,21032,16277,31458,13678,6880,23549,29245,22756,17958,621,19041,8543,24649,9871,7840,6642,28891,30518,20945,3117,1277,20372,2734,6898,11997,18605,20347,32644,7804,32523,1257,7393,14261,24755,21561,23890,18811,5977,15524,3648,19042,25296,21499,11849,15968,30660,31371,24979,10709,13995,1603,96,13770,20217,10521,29667,26998,8851,5801,21843,7431,32135,11551,829,2463,30202,9560,8478,6812,2146,3652,13617,25628,17397,6031,22662,25280,7008,28544,11604,26801,11709,14369,3984,23521,7103,22432,13246,10644,15664,10229,10248,4894,19102,18885,27533,14318,20305,7814,4091,203,30592,11749,6496,20574,3780,31332,4157,7409,17100,2376,31197,22390,32339,8626,10980,17355,28751,1804,10283,9788,4971,12966,2507,27210,18872,20641,5240,9898,24735,1037,32017,8849,4379,13902,2676,16431,20517,30148,2455,28793,879,10155,18389,5164,28244,4415,1925,28175,27407,31780,8913,2680,17452,31238,20678,16401,16957,2941,16551,11740,16846,11827,32647,23157,26011,5704,23574,22680,14592,5877,15548,5346,22192,32368,7140,12508,26538,26896,7835,3893,3689,20402,31065,30031,4699,21851,5918,26110,24469,6175,14017,6540,11973,2369,29317,14080,26984,4251,26094,12959,7741,32576,26067,30132,6649,5473,32435,13197,30780,8045,11597,4038,16580,28284,1386,31178,25825,12270,15102,24982,12584,26703,16751,10688,1900,5502,30005,31416,29930,15375,931,23375,30916,25581,1284,12917,3761,18500,31978,5703,20978,16030,13507,3145,19592,6476,9389,7919,18084,2311,24204,27747,10847,16855,12121,4738,20395,26420,27325,7207,17545,875,5342,21421,25981,3652,24185,7855,23103,18146,10033,18194,19124,25834,31270,21830,24604,25832,14538,24520,26253,29678,26608,29676,8864,15998,21286,31705,12138,9897,31301,17877,30894,9593,32070,4291,9552,23437,31319,16873,1549,5379,4654,10231,23658,17563,1694,28485,3562,14872,10088,11101,6020,6122,339,6585,21844,19467,895,462,29329,4135,3830,22089,5567,13567,9348,31640,7462,15631,9417,22444,32642,2670,22156,3837,9468,9207,10066,4815,19545,21926,23087,25780,20594,12356,6365,13139,25060,11335,6923,13415,2312,29684,22519,24587,1062,6342,30271,28980,21989,14355,28149,20351,6150,21229,4337,17965,26194,23879,28011,11371,30161,18520,16073,25303,11325,3141,24757,19009,19382,29946,30835,6062,1719,13912,18545,10659,4169,2966,25120,17056,31863,26081,10755,19690,1281,28230,25094,2957,1621,24274,11792,23714,18618,30456,18139,28878,27087,3890,20228,7179,31284,4075,32350,9131,9095,20381,6028,11674,27282,7223,23503,13539,25026,29633,28956,10101,24539,12354,28274,4392,3819,10978,618,30715,26493,6732,26640,19871,27662,12374,7665,6714,14533,15076,4981,17509,15198,19465,16495,6774,10088,11632,23283,261,31408,8955,8040,27305,9725,16553,24285,32003,11773,22461,18337,1790,22656,16157,7181,11348,14820,31480,19365,27221,14032,1963,8800,23012,20006,19430,579,21186,16178,30218,23348,21519,24616,18646,21774,22029,14541,6979,24561,26920,13684,4012,7900,17971,1580,17970,24701,13301,32312,3679,6727,26084,1983,23562,6598,14384,32709,890,24623,27907,3674,206,23612,20232,20241,20123,30262,23850,23988,4056,8787,25502,6966,4343,27971,9763,16105,25685,14086,32648,2033,7636,4096,6767,8953,29126,27727,10066,6181,15118,8540,13251,21831,11393,25008,1784,10325,12691,11018,10118,15899,16943,23214,28269,31021,11750,23551,19285,13600,8780,9552,7703,18937,28831,30456,18815,25574,22186,4260,25425,812,20201,20722,9609,14433,11246,29499,1255,28891,771,24495,4267,26472,10769,16808,32670,3391,19649,22584,3665,32567,23776,13572,4777,23351,25096,23894,26779,2542,27773,365,7221,20676,12117,15896,29918,16400,1500,7299,17886,20875,26678,17488,10273,19205,4934,5097,311,14678,26575,4885,31648,6040,17625,29642,21575,30355,24919,5443,8524,14457,26886,15697,30214,13524,24728,31734,2121,22716,5394,27952,15076,5965,6771,19731,12654,15960,7574,4634,20803,857,3417,447,21449,23721,24319,29513,19960,31477,29139,13542,20761,30447,22030,18169,2253,1859,31483,25013,31314,21197,2137,30955,18690,13065,26369,12832,9244,31435,15561,227,16839,5424,24487,23902,2900,4308,1050,18730,24260,27461,10949,5736,2442,12472,4445,9485,24722,17403,10950,2685,6529,25259,25209,22364,18751,14759,12073,28576,11187,7620,14502,10475,6349,15555,5377,8985,19146,23168,24817,3860,22963,28267,14197,22512,4135,13628,19643,25140,32091,2787,12353,21877,26719,8382,31290,9258,2211,25615,26675,17851,10169,10413,11510,22235,4188,27642,30639,5144,28338,17428,30285,25264,1486,20304,22315,23463,24185,14308,3568,3350,21298,8163,24500,26054,7539,2415,31332,32509,18486,3882,7015,14488,11192,237,2433,23386,22141,14525,26104,13700,1940,15354,6390,26022,7708,31962,23855,18356,8711,20502,11971,14428,18974,27363,8550,8855,9029,32036,25022,2943,15617,15326,26124,4192,32567,28652,4623,2833,3383,23796,21030,20613,23032,5273,29108,15773,20901,2546,12488,1600,15449,31035,23806,31406,15912,30667,29088,14097,6238,16454,785,29014,4107,3860,31084,22842,7615,8978,24168,16040,19090,13959,17023,29250,24167,1113,32079,5182,17266,11649,19776,17779,17144,4796,6759,28339,32598,30339,24746,4700,20293,31550,1317,23594,24156,20917,6861,25423,14039,11207,23123,21190,6294,18270,20812,27620,16745,9634,3214,5936,2698,17005,16861,30580,32619,24575,15559,13076,20914,15092,4812,26527,20098,14963,25282,31652,14589,28839,9080,17095,11783,32627,17818,10259,30028,13665,11476,21138,25476,30428,17466,30747,12790,18336,12776,21100,28474,2158,28133,27257,27972,15620,16462,11779,20638,28236,27312,875,9461,31956,181,20425,6871,30590,13315,9017,21179,19065,5985,32629,22850,23151,7451,27817,14524,24576,21672,20610,17390,6000,11147,15240,32275,6300,13687,8367,17440,27443,16310,11048,6988,11042,13260,9853,18640,20816,3415,11485,5867,29836,26425,4021,27434,5828,25593,11904,4582,21111,30055,12255,25358,31852,18303,20716,9255,3493,21136,16075,19344,27023,22686,11907,2315,21627,20996,9996,14201,11857,3421,12714,7141,17795,1701,25721,5572,22081,14748,31560,9339,2540,29547,29354,26146,2764,26506,22859,29576,5,3041,19329,15735,1479,46,19747,20281,30150,1190,30110,6746,5098,17375,8773,12208,29511,29677,8937,2457,10063,4812,5290,19332,5446,16894,24332,6835,31223,1396,1870,29759,30630,27058,19959,9308,16453,21807,19121,17118,12267,2298,31322,22780,27521,5283,29529,5204,22463,16729,13358,11056,31831,14416,16461,22024,10095,26726,32557,584,25941,28421,4508,8786,8302,2123,4437,16071,32112,19048,28372,11523,18385,12360,24937,3814,640,14195,7564,32730,28882,5425,17776,4881,11199,18161,18395,1807,5966,491,8500,21097,19534,17925,13022,28108,19015,6131,9412,32576,1456,9891,1333,19118,9826,24536,6899,2976,2637,14357,7558,7241,24682,10684,18390,3525,28656,12151,30969,5538,24523,15831,22346,29854,4682,59,10683,15026,26904,23796,23404,3152,1389,1190,23932,19690,22661,4337,23327,21171,6226,30289,29680,1961,27758,19779,28809,7123,26451,13994,9553,11463,8142,24432,30614,1648,32433,26480,14556,24846,5321,12180,19572,16510,3343,21306,19280,22716,3874,20701,6677,7078,9717,9713,9586,21507,32453,25102,14513,29123,5199,30033,8843,27528,6719,15872,7233,22886,15595,6508,9960,11495,2369,31772,21252,10835,4350,21799,9817,1838,7970,16610,5118,20993,4256,20155,15027,1886,9561,24165,23924,30750,23883,22582,19023,25837,13830,17613,9074,29449,23648,2039,16008,24134,9834,17108,3654,3158,27043,8501,19008,25927,363,5705,18690,5453,6586,19577,16476,7106,4625,19600,24573,19307,3249,8223,31299,8189,32268,29472,12114,3295,20601,30937,20068,10546,28715,6147,24928,23823,21348,8748,5805,29711,21222,6746,32072,14609,26283,20209,18196,32567,6869,19158,1394,15410,20712,25045,5138,6080,8503,23616,9737,5234,28828,1497,10531,13747,3692,9202,29562,18182,28330,5843,28487,10383,21627,10844,14585,17621,218,23020,25476,5062,14733,2945,22268,20220,15448,1568,32098,15166,29296,10103,12734,11082,30770,7361,9581,8145,19733,8938,12221,10436,16350,4595,15287,27598,27411,14233,18492,29730,21937,17713,11860,12150,3105,21719,8642,15439,17769,18887,8156,28032,26784,4107,16537,9965,1700,32599,7660,30613,7183,25905,17744,5328,12134,31316,26532,6868,8084,18263,15162,13950,13975,15498,17451,7248,21626,289,30445,28854,18051,15764,26919,1421,7853,25925,1219,4325,8024,17252,28997,16646,3904,20239,10076,20914,2476,2750,25271,1706,7912,29407,26138,12148,22772,16317,17841,6234,30846,32422,11172,3254,32270,17997,19179,20077,21377,2669,29796,9914,10680,21167,547,29741,24209,22734,3337,23027,32534,20985,8344,29783,14837,26489,24837,13961,22065,8851,22415,21918,534,20400,22800,25817,3698,7355,15058,1833,27138,30411,18851,23026,28971,27394,14124,32016,26090,3765,29054,23578,9230,13004,6382,7395,26021,26220,2083,22343,11188,3284,8813,31268,7979,2693,23640,422,32279,19878,12930,25288,26906,13734,681,20503,9496,7715,31496,15289,9524,4363,5092,15023,28923,25601,18274,11607,15070,17666,31643,20789,15078,31304,21234,8178,8611,22894,22182,8101,14182,14806,12195,2130,31664,26184,24990,25264,22761,20955,15456,1072,16469,5145,30562,3130,16965,28766,11163,18106,30346,27777,8086,6107,18735,15030,6599,21778,32616,31411,11551,12127,2245,5650,13278,4816,28843,15351,27817,8006,1029,16370,28124,7803,32567,24615,25377,6980,22611,13996,18754,32276,31120,23090,7227,21186,32760,29160,11156,7052,21088,16540,2285,21851,9373,27427,17627,4425,15093,32252,28146,18272,468,30256,1571,18084,19904,20860,25161,26196,22415,27058,10238,23662,18648,8029,23987,23921,27815,6052,16640,26982,22645,4465,22328,27169,8535,5586,27713,1733,29045,1951,29602,20614,4542,22109,32734,11443,15322,22626,17409,8179,18528,4154,21368,24271,3402,24906,5157,18288,166,30643,5811,10410,29582,26489,18727,31290,31065,18149,14264,27212,20243,18471,20449,25665,22315,5696,22964,29870,32108,31007,7025,11944,5934,1290,23383,30271,5070,22848,13242,21576,4443,12765,27990,14176,10642,20733,21475,17965,2829,804,14570,9959,12983,17118,6358,24599,22915,16290,5710,13983,27230,19452,16322,11515,5218,30444,21316,1990,19788,21641,29850,31616,22576,14825,2449,26510,9323,28741,12436,17026,6362,9049,1404,7069,8009,3850,10410,21906,1070,12363,15443,32397,32408,32065,19484,26996,29794,26789,21223,27757,20140,13419,21228,26784,29323,22433,13323,32574,12800,31641,23648,6082,18727,21578,14105,7031,15281,22516,7556,2618,9876,6659,22124,19585,23041,19766,8102,26268,20375,12544,30183,28987,20694,28207,3801,31537,25046,9931,14701,14455,17465,15681,6258,8820,9822,5824,27495,28027,21207,23780,22925,30614,29726,658,29505,5250,16515,4131,23945,23290,8809,31428,23533,22329,12466,2844,11400,18106,2936,5936,27230,16706,28926,4996,27120,29472,7910,16259,17422,19635,21412,28961,749,19246,1074,17343,9593,16024,6661,11855,27884,12567,19777,17592,10400,21357,28457,10364,29729,4803,14553,27800,7047,15270,29239,28844,6659,20047,1319,30555,26295,26663,20734,31733,971,26250,21050,2899,957,9931,29296,9219,30968,1913,5253,24998,937,3809,12577,30613,29134,23252,5985,16075,9615,15787,9676,23295,13778,11399,3977,15120,32010,25310,463,30886,2639,24371,15772,23319,10420,7460,31146,391,28885,12458,8351,30804,6319,9885,16259,15793,30133,20086,14456,31120,25888,20825,3493,27846,3718,14931,22644,23401,13486,21472,16637,30333,2211,32432,2498,2256,13063,26026,924,27427,1962,13106,32245,906,5979,11175,1848,21526,5118,20784,4486,23728,15071,29881,20395,21576,14662,22584,24144,32048,16204,17973,3441,6338,13548,17033,24082,15945,17757,14438,2094,6431,13471,18839,7409,21010,13141,8969,6439,10252,9426,31371,31731,31732,2934,6610,13764,21455,3899,6848,901,6443,21131,14566,2580,5821,2389,23623,17910,31049,1631,16734,9033,22466,13022,25187,20985,1715,9284,1483,10807,15069,17497,5646,13607,16161,16269,9900,11737,16801,11660,19058,3707,31779,10260,7929,32205,15286,17411,12657,12501,2967,8373,8348,5331,1877,396,8221,21879,6196,9680,16627,4946,8655,21178,9025,24203,25090,17355,30032,18899,2055,30050,25558,10650,18143,32142,24441,21379,26356,26401,23439,29206,6908,17158,27176,16566,7200,25556,22862,17362,20830,30626,13707,20831,1580,29726,21932,32133,29790,2265,21445,16280,9545,3045,6005,25419,28201,5282,21867,6688,3008,14549,10281,16675,8512,8186,9736,11992,7787,24796,6269,7538,20729,23906,14490,1349,9530,4268,5336,31614,23036,862,1043,26898,11183,23100,18902,11764,15047,13048,20441,1163,12642,17223,6344,14691,27691,28218,20550,2851,10878,17356,7218,18111,2509,7864,4905,29678,20546,21645,31820,9695,19109,11267,15427,17447,16769,3472,4994,24575,18818,8759,4554,27052,29474,21665,25331,23102,7556,26734,22762,9597,28832,7117,22262,2081,17057,1866,575,1601,27787,12264,23440,11790,21025,32624,9820,29377,8454,5896,16639,13266,2850,12295,21063,17515,71,32520,28723,1820,11029,19774,9210,29136,13595,15367,28495,3584,5694,26307,14052,18726,29535,22246,13869,10613,20536,32332,24678,15047,6279,11213,21207,18391,17519,11794,15447,13232,7195,6310,24079,1893,24228,24400,2432,2051,20533,15265,16328,26820,29549,4297,22048,28037,29188,16815,17322,4474,30898,11584,31850,1569,2636,17670,32145,7796,3633,29181,28418,31331,7652,15267,32271,1665,22010,25935,21891,9214,11831,30147,22246,3285,7412,23812,30972,18502,2499,11370,28559,17287,21334,5363,110,25271,27805,8156,10678,7699,21807,21875,32080,32620,28907,17959,21947,5081,735,10721,18444,9641,20329,2455,30515,21147,10651,10014,11391,21074,28644,5951,22885,259,15341,16910,26237,625,18882,15735,29645,4379,23090,13850,28234,19891,5240,23129,7836,8915,11035,31662,5410,4332,18450,23106,5942,30335,1068,20156,29106,10383,28079,18007,21682,28502,25151,17720,7324,15159,16386,25342,11358,9716,12802,30106,15607,5153,7123,24161,17977,2776,26741,11615,25805,3503,16507,3823,24951,6375,27501,14217,15771,3046,24684,16858,26881,6119,18964,13082,1237,1777,423,6554,22514,28421,17767,31132,22624,9628,11843,31848,28186,1873,10422,5532,21269,26586,29933,4804,13439,15932,29224,18730,31044,24895,14690,22000,20951,26656,19252,9307,29999,903,21751,11890,12048,25272,20777,11208,9099,30989,1809,8854,27592,14244,11686,3852,28675,3925,13742,5353,8917,20199,32547,28490,437,12675,32218,4799,32446,12648,4455,13732,14259,29409,5179,12975,7744,23412,26127,31173,30082,10589,30086,786,18634,7995,3341,30808,16286,6152,26374,2183,29441,5966,19751,6543,10229,10648,18204,19570,4925,10535,7284,1949,2663,15079,11706,31608,17930,6050,26850,21820,6477,30066,23784,5125,17064,9596,12467,13352,14831,14811,319,9414,8076,18395,27387,15265,12555,6760,17008,6959,26333,26822,16420,16109,8021,25986,9150,8694,31479,14760,4714,13268,19954,16438,13439,3990,19179,5585,22112,10530,19196,20663,4256,25805,22269,29941,15209,19753,22018,30938,12574,23326,1316,28075,9279,1085,7301,8344,3213,848,17806,18415,28527,3894,18043,4240,1941,29678,1818,8097,4059,16881,21199,23682,13680,1989,31708,5891,30007,18895,17375,24021,26733,11369,11676,6463,17549,1076,7165,15890,4720,16559,25175,11487,24761,25865,10735,4455,30064,820,20669,22099,17133,27963,9584,294,9208,4309,9394,2671,9006,12602,7084,1603,20903,29493,21453,12522,28885,28539,11207,13273,29615,16187,16859,14048,6927,14070,4951,4517,12633,17297,13661,12625,10590,7593,2789,1673,9344,18214,7173,4000,9238,1811,29297,21259,27154,22445,7998,24085,19681,31417,19947,7124,658,10267,2209,6235,10043,2725,4538,1073,664,32557,30337,3074,20726,18914,16184,22677,4943,13792,24672,19198,10935,21249,20788,18709,17142,17910,27511,11814,20599,24215,30831,13290,9569,26744,3890,26550,25091,27069,10272,32755,17525,17455,2481,9678,7036,27791,29297,1840,24751,11306,9288,17649,15832,8365,13567,4425,413,28219,18432,4743,18272,22461,5469,24069,22115,12665,25108,8027,31792,25063,19858,16339,26168,25791,6261,8733,16058,1111,18582,17988,4326,15660,20039,27105,14403,32702,3801,30863,24398,17570,30818,24734,20836,9938,700,8204,9185,30791,16849,7600,31370,1226,27926,8889,27432,30471,86,2135,17526,5091,22961,28088,15421,16399,30948,2614,18622,989,17355,28623,10576,339,29732,20949,25162,4223,4757,9190,12323,30217,8945,9503,13784,26639,26039,11149,27278,21804,21211,17380,2681,8666,12745,31092,3836,20475,29352,23128,29202,17586,11483,3057,16620,8311,26318,915,16860,23915,2799,14205,12657,10216,11770,23567,23268,9565,2682,311,4018,7513,21901,9261,17035,14565,20711,2400,18795,19479,15897,29360,2823,24036,5907,1501,7018,25142,12264,30527,3040,23102,9682,19640,29203,20236,16246,19688,27252,23133,8809,28319,6620,12724,498,23704,29299,26540,11026,24932,16338,22412,4545,20388,15972,28444,17275,14971,16914,19127,25339,4675,12319,22434,4423,31103,20560,28828,26604,26129,14673,10422,26763,25262,23636,14437,1428,1166,29691,16598,10322,26984,23160,22913,22568,20893,2803,7169,26394,10932,21035,8739,18318,7686,29281,10813,28500,30650,15986,21953,27621,31220,28739,13841,3048,28746,15969,7061,16891,6008,29929,23308,9391,11604,5542,32031,12244,15620,17274,3132,11000,31598,31999,29857,22826,18416,27245,10935,22020,9553,17087,2978,17384,16120,3089,11286,12169,20060,15181,2412,19629,29884,30470,20725,28722,23824,420,12686,27471,14911,3778,27508,11293,30098,2004,4698,18262,8553,1037,13753,20316,1069,30592,25448,7293,20357,23941,14444,27253,22477,25182,29713,28468,24516,20506,16698,20194,19588,17082,10741,4385,21944,26515,26962,31634,1545,19443,3958,30106,8153,32519,11243,22886,14900,2812,29242,22060,10755,2405,3260,18356,2947,22237,4525,10008,32758,10733,20098,30920,29593,4400,23932,23504,32725,7348,14718,7774,15801,13988,17436,31614,7336,28452,29172,26153,4431,16253,4417,1406,12506,2170,24237,17999,3176,20498,23655,9695,24764,582,8054,6634,28213,14669,1869,14822,3328,20719,5023,3465,20876,18735,19572,9355,21822,15404,28797,23469,30567,27465,23972,29434,10867,10124,26600,22861,8547,6468,4712,20755,29053,10991,24253,21074,31809,7002,9869,19947,13728,31498,13149,13852,6761,6363,2215,28744,27396,8679,5165,5115,32354,30889,14476,6953,16692,1891,26132,26550,13659,4540,13783,16955,1440,18862,15104,13832,422,11167,32359,28261,5660,26062,22626,31006,5431,20209,7389,4670,25440,12317,19885,23834,23594,26085,18209,11921,902,7366,6874,19603,22330,11459,3293,18144,21647,22604,26343,19730,1610,29284,5633,9694,11998,12291,18003,11159,25312,10425,28989,29171,10171,19093,4516,30994,27301,17733,29322,4540,25554,12414,19426,22251,14823,29087,8610,24713,31153,9361,6425,4986,13847,3057,14467,13021,25677,19569,17627,5775,18507,30587,12784,10993,1406,10520,22715,7660,10173,15633,26608,23858,14462,24404,17107,18886,13386,31640,16973,17598,29806,20548,3135,31048,24820,10381,29974,2027,32465,479,8096,30479,11872,8319,20254,3264,11791,22382,8090,30127,13657,1936,6266,23929,15348,6669,19798,23596,16715,31224,263,23816,10286,20783,32512,25218,31432,3202,7906,19343,10962,27415,9802,32286,8711,7436,31981,6886,14040,13663,26344,7779,22880,29451,14673,4891,3226,9588,15634,14630,32722,12293,13303,18157,23641,28952,13317,10034,7037,4118,19726,22609,30904,30431,11394,20677,21544,31340,13192,3309,6463,30387,13133,10768,32188,25034,17308,12960,11482,6736,26544,32699,12999,29961,30022,21495,15447,19912,29174,4959,32506,8082,23234,15545,23788,26624,2544,2059,6571,23013,12053,20061,12974,9009,3443,7871,12372,18965};
        test.maximumGap(t);
    }

    static class findMissingRanges {
        public List<String> findMissingRanges(int[] nums, int lower, int upper) {
            long lower_ = lower;
            long upper_ = upper;
            List<String> result = new ArrayList<>();
            if(nums.length == 0){
                if (lower_ < upper_){
                    result.add(lower_ + "->" + upper_);
                }else if (lower_ == upper_){
                    result.add(lower_+"");
                }
                return result;
            }
            if (nums[0] != lower){
                lower_ = lower_ - 1;
            }
            if (nums[nums.length - 1] != upper){
                upper_ = upper_ + 1;
            }

            for (int i = 0; i <= nums.length; i++){
                long left;
                long right;
                if (i == 0){
                    left = lower_ + 1;
                    right = Long.valueOf(nums[i]) - 1;
                }else if (i == nums.length){
                    left = Long.valueOf(nums[i-1]) + 1;
                    right = upper_ - 1;
                }else{
                    left = Long.valueOf(nums[i-1]) + 1;
                    right = Long.valueOf(nums[i]) - 1;
                }
                if (left < right){
                    result.add(left + "->" + right);
                }else if (left == right){
                    result.add(left+"");
                }
            }
            return result;
        }
    }

    static class distanceK {
        public List<Integer> distanceK(TreeNode root, TreeNode target, int K) {
            List<Integer> result = new ArrayList<>();
            if (root == null){
                return result;
            }

            HashMap<TreeNode, TreeNode> map = new HashMap<>();
            distanceKMapBuilder(root, map);
            distanceKHelper(target, map, null, K, result);

            return result;
        }
        private void distanceKMapBuilder(TreeNode root, HashMap<TreeNode, TreeNode> map){
            if (root.left != null){
                map.put(root.left, root);
                distanceKMapBuilder(root.left, map);
            }
            if (root.right != null){
                map.put(root.right, root);
                distanceKMapBuilder(root.right, map);
            }
        }
        private void distanceKHelper(TreeNode root, HashMap<TreeNode, TreeNode> map, TreeNode pre, int K, List<Integer> result){
            if (root != null && K == 0){
                result.add(root.val);
            }
            if (root.left != null && root.left != pre){
                distanceKHelper(root.left, map, root, K - 1, result);
            }
            if (root.right != null && root.right != pre){
                distanceKHelper(root.right, map, root, K - 1, result);
            }
            if (map.get(root) != null && pre != map.get(root)){
                distanceKHelper(map.get(root), map, root, K - 1, result);
            }
        }
    }

    static class shortestDistance {

        public int shortestDistance(String[] words, String word1, String word2) {

            int count = Integer.MAX_VALUE;
            int indexOne = -1;
            int indexTwo = -1;
            for(int i = 0; i < words.length; i++){
                if(words[i].equals(word1)){
                    if (indexTwo == -1){
                        indexOne = i;
                    }else{
                        indexOne = i;
                        count = Math.min(count, Math.abs(indexOne - indexTwo));
                    }
                }
                 if (words[i].equals(word2)){
                     if (indexOne == -1){
                         indexTwo = i;
                     }else{
                         indexTwo = i;
                         count = Math.min(count, Math.abs(indexOne - indexTwo));
                     }
                 }
            }
            return count;
        }
    }

    static class maxIncreaseKeepingSkyline {
        public int maxIncreaseKeepingSkyline(int[][] grid) {
            if (grid.length == 0){
                return 0;
            }
            int[] topBotMax = new int[grid[0].length];
            int[] leftRightMax = new int[grid.length];
            for(int i = 0; i < grid.length; i++){
                for (int j = 0; j < grid[i].length; j++){
                    topBotMax[j] = Math.max(topBotMax[j], grid[i][j]);
                    leftRightMax[i] = Math.max(leftRightMax[i], grid[i][j]);
                }
            }
            int increase = 0;
            for(int i = 0; i < grid.length; i++){
                for (int j = 0; j < grid[i].length; j++){
                    increase += (Math.min(leftRightMax[i], topBotMax[j]) - grid[i][j]);
                }
            }
            return increase;
        }
    }
    static class numJewelsInStones {
        public int numJewelsInStones(String J, String S) {
            if (J.length() == 0 || S.length() == 0){
                return 0;
            }
            HashSet<Character> set = new HashSet<>();
            for(int i = 0; i < J.length(); i++){
                if (!set.contains(J.charAt(i))){
                    set.add(J.charAt(i));
                }
            }
            int count = 0;
            for(int i = 0; i < S.length(); i++){
                if (set.contains(S.charAt(i))){
                    count++;
                }
            }
            return count;
        }
    }
    static class regionsBySlashes {
        public int regionsBySlashes(String[] grid) {
            int[][] newGrid = new int[grid.length * 3][grid.length * 3];
            for (int i = 0; i < grid.length; i++) {
                for (int j = 0; j < grid[i].length(); j++) {
                    if (grid[i].charAt(j) == '/') {
                        int i_ = i * 3;
                        int j_ = j * 3;
                        newGrid[i_][j_ + 2] = 1;
                        newGrid[i_ + 1][j_ + 1] = 1;
                        newGrid[i_ + 2][j_] = 1;

                    } else if (grid[i].charAt(j) == '\\') {
                        int i_ = i * 3;
                        int j_ = j * 3;
                        newGrid[i_][j_] = 1;
                        newGrid[i_ + 1][j_ + 1] = 1;
                        newGrid[i_ + 2][j_ + 2] = 1;
                    }
                }
            }
            int cnt = 0;
            for (int i = 0; i < newGrid.length; i++) {
                for (int j = 0; j < newGrid[0].length; j++) {
                    if (newGrid[i][j] == 0) {
                        regionsBySlashesHelper(newGrid, i, j);
                        cnt++;
                    }
                }
            }
            return cnt;
        }
        private void regionsBySlashesHelper(int[][] g, int i, int j){
            int n = g.length, m = g[0].length;
            if(i<0 || i>=n || j<0 || j>=m || g[i][j]==1) return;
            g[i][j]=1;
            int d[] = {0,-1,0,1,0};
            for(int k=0;k<4;k++){
                regionsBySlashesHelper(g,i+d[k],j+d[k+1]);
            }
        }
    }



    static class buildTree {
        public TreeNode buildTree(int[] preorder, int[] inorder) {
            if (preorder.length == 0){
                return null;
            }
            return buildTreeHelper(preorder, 0, inorder, 0, inorder.length-1);
        }
        private TreeNode buildTreeHelper(int[] preorder, int preStart, int[] inorder, int inStart,int inEnd){
            if (preStart > preorder.length - 1 || inStart > inEnd) {
                return null;
            }
            TreeNode root = new TreeNode(preorder[preStart]);
            int rootIndex = inStart;
            while (preorder[preStart] != inorder[rootIndex]){
                rootIndex++;
            }
            root.left = buildTreeHelper(preorder, preStart + 1, inorder, inStart, rootIndex - 1);
            root.right = buildTreeHelper(preorder, preStart + rootIndex - inStart + 1, inorder, rootIndex + 1, inEnd);


            return root;
        }
    }
    static class merge {
        public void merge(int[] nums1, int m, int[] nums2, int n) {
            int i = m-1;
            int j = n-1;
            int k = m+n-1;
            while (i >= 0 && j >= 0){
                if (nums1[i] >= nums2[j]){
                    nums1[k] = nums1[i];
                    i--;
                    k--;
                }else {
                    nums1[k] = nums2[j];
                    j--;
                    k--;
                }
            }

            while (i >= 0){
                nums1[k] = nums1[i];
                k--;
                i--;
            }
            while (j >= 0){
                nums1[k] = nums2[j];
                k--;
                j--;
            }
        }
    }

    static class numDecodings {
        public int numDecodings(String s) {
            if (s.length() == 0 || s.charAt(0) == '0'){
                return 0;
            }
            int[] ans = new int[s.length()+1];
            ans[0] = 1;
            ans[1] = s.charAt(1) != '0' ? 1 : 0;
            int i = 2;
            for (i = 2;i < ans.length;i++){
                if (i < s.length() && s.charAt(i) == '0'){
                    continue;
                }
                if (Integer.parseInt(s.substring(i-2,i))<= 26){
                    ans[i] = ans[i-2] + ans[i-1];
                }else {
                    ans[i] = ans[i-1];
                }
            }
            return ans[ans.length-1];
        }
    }

    static class pushDominoes {
        public String pushDominoes(String dominoes) {
            StringBuilder domiBuilder = new StringBuilder(dominoes);
            int i = 0;
            int j = 0;
            for (j = 0; j < domiBuilder.length(); j++){
                if (domiBuilder.charAt(j) == 'R'){
                    if (domiBuilder.charAt(i) == 'R'){
                        while (i < j){
                            domiBuilder.replace(i, i+1, "R");
                            i++;
                        }
                    }else{
                        i = j;
                    }
                }else if (domiBuilder.charAt(j) == 'L'){
                    if (domiBuilder.charAt(i) == 'R'){
                        int i_ = i;
                        int j_ = j;
                        while (i_ < j_){
                            domiBuilder.replace(i_, i_+1,"R");
                            domiBuilder.replace(j_, j_+1,"L");
                            i_++; j_--;
                        }
                        if (i_ == j_){
                            domiBuilder.replace(i_, i_+1, ".");
                        }
                        i = j;
                    }else{
                        while (i < j){
                            domiBuilder.replace(i, i+1, "L");
                            i++;
                        }
                    }
                }
            }
            if (domiBuilder.charAt(j-1) == '.' && domiBuilder.charAt(i) == 'R'){
                while (i < j){
                    domiBuilder.replace(i, i+1, "R");
                    i++;
                }
            }
            return domiBuilder.toString();
        }
    }

    static class groupAnagrams {
        public List<List<String>> groupAnagrams(String[] strs) {
            HashMap<String, ArrayList> map = new HashMap<>();
            for(String s : strs){
                String temp = groupAnagramsHashHelper(s);
                if (map.containsKey(temp)){
                    map.get(temp).add(s);
                }else {
                    ArrayList<String> tempList = new ArrayList<>();
                    tempList.add(s);
                    map.put(temp, tempList);
                }
            }
            List<List<String>> result = new ArrayList<>();
            for (ArrayList v : map.values()){
                result.add(v);
            }
            return result;
        }
        private String groupAnagramsHashHelper(String s){
            int cap = 26;
            StringBuilder charCounter = new StringBuilder(cap);
            for (int i = 0; i < cap; i++){
                charCounter.append("0");
            }
            for (int i = 0; i < s.length(); i++){
                int temp =  (int) s.charAt(i);
                temp -= 97;
                int t = (Character.getNumericValue(charCounter.charAt(temp)) + 1);
                char tt = Character.forDigit(t, 10);
                charCounter.setCharAt(temp, tt);
            }


            return charCounter.toString();
        }
    }
    static class searchMatrix {
        public boolean searchMatrix(int[][] matrix, int target) {
            if (matrix.length == 0 || matrix[0].length == 0) return false;
            int rowNum = matrix.length / 2;
            int minRow = 0;
            int maxRow = matrix.length - 1;
            while (minRow <= maxRow){
                if (target < matrix[rowNum][0]){
                    maxRow = rowNum - 1;
                    rowNum = minRow + (maxRow - minRow)/2;
                } else if (target > matrix[rowNum][0]){
                    minRow = rowNum + 1;
                    rowNum = minRow + (maxRow - minRow)/2;
                } else if (target == matrix[rowNum][0]){
                    return true;
                }
            }

            if (minRow == 0){
                return false;
            }
            int min = 0;
            int max = matrix[0].length - 1;
            int row = minRow - 1;
            while (min <= max && min >= 0 && max < matrix[0].length) {
                int mid = min + (max - min) / 2;
                if (matrix[row][mid] == target) return true;
                else if (target < matrix[row][mid]) max = mid - 1;
                else min = mid + 1;
            }

            return false;
        }
    }

    static class setZeroes {
        public void setZeroes(int[][] matrix) {
            HashSet<Integer> rowSet = new HashSet<>();
            HashSet<Integer> colSet = new HashSet<>();
            for (int i = 0; i < matrix.length; i++){
                for (int j = 0; j < matrix[i].length; j++){
                    if (matrix[i][j] == 0){
                        rowSet.add(i);
                        colSet.add(j);
                    }
                }
            }
            for (Integer rownum : rowSet){
                for (int j = 0; j < matrix[rownum].length; j++){
                    matrix[rownum][j] = 0;
                }
            }
            for (Integer colnum : colSet){
                for (int i = 0; i < matrix.length; i++){
                    matrix[i][colnum] = 0;
                }
            }
        }
    }

    static class inorderTraversal {
        public List<Integer> inorderTraversal(TreeNode root) {
            List<Integer> result = new ArrayList<>();
            helper(root, result);
            return result;
        }
        private void helper(TreeNode root, List<Integer> result){
            if (root == null){
                return;
            }

            helper(root.left, result);
            result.add(root.val);
            helper(root.right,result);

        }
    }
    static class minWindow {
        public String minWindow(String s, String t) {
            HashMap<Character, Integer> tmap = new HashMap<Character, Integer>();
            for (int i = 0; i < t.length(); i++){
                if (tmap.containsKey(t.charAt(i))){
                    tmap.put(t.charAt(i), tmap.get(t.charAt(i))-1);
                }else{
                    tmap.put(t.charAt(i), -1);
                }

            }
            int tLength = t.length();

            int L = 0;
            int R = 0;
            String result = "";

            while (R < s.length()){

                if (tmap.containsKey(s.charAt(R))){
                    tmap.put(s.charAt(R), tmap.get(s.charAt(R)) + 1);
                    if (tmap.get(s.charAt(R)) <= 0){
                        tLength--;
                    }
                }
                while (tLength == 0){
                    if (result == "" ||(R - L) < result.length()){
                        result = s.substring(L, R+1);
                    }
                    if (tmap.containsKey(s.charAt(L))){
                        tmap.put(s.charAt(L), tmap.get(s.charAt(L)) - 1);
                        if (tmap.get(s.charAt(L)) < 0) {
                            tLength++;
                        }
                    }
                    L++;
                }
                R++;
            }
            return result;
        }
    }

    static class videoStitching {

        public int videoStitching(int[][] clips, int T) {

            Arrays.sort(clips, new Comparator<int[]>() {
                public int compare(int[] a, int[] b) {
                    if (a[0] != b[0]) {
                        return a[0] - b[0];
                    }
                    return - Integer.compare(a[1], b[1]);
                }
            });
            if (clips[0][0] > 0){
                return -1;
            }
            int end = clips[0][1];
            int result = 1;
            int i = 1;
            int maxend = end;
            if (end >= T){
                return result;
            }
            while (i < clips.length){
                while ( i < clips.length && clips[i][0] <= end){
                    maxend = Math.max(clips[i][1], maxend);
                    i++;
                }
                if (maxend == end){
                    i++;
                }else {
                    end = maxend;
                    result++;
                }
                if (end >= T){
                    return result;
                }
            }
            return -1;
        }
    }

    static class generateParenthesis {
        public List<String> generateParenthesis(int n) {
            List<String> result = new LinkedList<>();
            gpHelper(result, "", n, n);

            return result;
        }
        private void gpHelper(List<String> result, String temp, int left, int right){
            if (left == 0 && right == 0){
                result.add(temp);
            }
            if (left > 0){
                gpHelper(result, temp+"(", left - 1, right);
            }
            if (left < right){
                gpHelper(result, temp + ")", left, right - 1);
            }
        }
    }

    static class isValid {
        public boolean isValid(String s) {
            Stack<Character> list = new Stack<>();
            for (int i = 0; i <s.length(); i++){
                char c = s.charAt(i);
                if (c == '(' || c == '[' || c == '{'){
                    list.push(c);
                }else {
                    if(list.empty()){
                        return false;
                    }
                    char p = list.pop();
                    if (!((p == '(' && c == ')') || (p == '{' && c == '}') || (p == '[' && c == ']'))){
                        return false;
                    }
                }
            }
            if(!list.empty()){
                return false;
            }
            return true;
        }
    }

    static class simplifyPath {
        public String simplifyPath(String path) {
            String [] arrofFiles = path.split("/");

            Stack<String> l = new Stack<String>();
            for (int i = 0; i < arrofFiles.length; i++) {
                if (arrofFiles[i].equals("") || arrofFiles[i].equals(".") ){
                }else if (arrofFiles[i].equals("..") && !l.empty()){
                    l.pop();
                }else {
                    l.push(arrofFiles[i]);
                }
            }
            String result = "";
            while (!l.empty()){
                result = "/" + l.pop() + result;

            }
            if (result == ""){
                return "/";
            }
            return result;
        }
    }

    static class reverseBetween {
        public ListNode reverseBetween(ListNode head, int m, int n) {
            if(head == null || m == n){
                return head;
            }
            int i = 1;
            ListNode start = null;
            ListNode pre = head;
            ListNode pointer = head.next;
            while (i < m){
                i++;
                start = pre;
                pre = pre.next;
                pointer = pointer.next;
            }
            ListNode k = pre;

            while(pointer != null && i < n){
                i++;
                ListNode temp = pointer;
                pointer = temp.next;
                temp.next = pre;
                pre = temp;
            }
            k.next = pointer;
            if (start == null){
                //head.next = null;
                return pre;
            }else {
                start.next = pre;
                return head;
            }
        }
    }

    static class reverseList {
        public ListNode reverseList(ListNode head) {
            ListNode pre = head;
            ListNode pointer = head.next;
            while(pointer != null){
                ListNode temp = pointer;
                pointer = temp.next;
                temp.next = pre;
                pre = temp;
            }
            head.next = null;
            return pre;
        }
    }
    static class sortColors {
        public void sortColors(int[] nums) {
            int zeroP = 0;
            int twoP = nums.length - 1;
            int pointer = 0;
            while (pointer <= twoP){
                if (nums[pointer] == 0){
                    int temp = nums[zeroP];
                    nums[pointer] = temp;
                    nums[zeroP] = 0;
                    zeroP++;
                }
                else if (nums[pointer] == 2){
                    int temp = nums[twoP];
                    nums[pointer] = temp;
                    nums[twoP] = 2;
                    twoP--;
                }
                if (pointer < zeroP || nums[pointer] == 1){
                    pointer++;
                }
            }
        }
    }
    static class uniquePathsWithObstacles {
        public int uniquePathsWithObstacles(int[][] obstacleGrid) {
            int m = obstacleGrid.length;
            int n = obstacleGrid[0].length;
            int[][] map = new int[m][n];
            map[0][0] = 1;
            for (int i = 0; i < m; i++){
                for (int j = 0; j < n; j++){
                    if (i - 1  >= 0){
                        map[i][j] += map[i-1][j];
                    }
                    if (j - 1 >= 0 && obstacleGrid[i][j-1] != 1){
                        map[i][j] += map[i][j-1];
                    }
                    if (obstacleGrid[i][j] == 1){
                        map[i][j] = 0;
                    }
                }
            }
            return map[m-1][n-1];
        }
    }

    static class uniquePaths {
        public int uniquePaths(int m, int n) {
            int[][] map = new int[m][n];
            map[0][0] = 1;
            for (int i = 0; i < m; i++){
                for (int j = 0; j < n; j++){
                    if (i - 1  >= 0){
                        map[i][j] += map[i-1][j];
                    }
                    if (j - 1 >= 0){
                        map[i][j] += map[i][j-1];
                    }
                }
            }


            return map[m-1][n-1];
        }
    }

    static class letterCombinations {
        public List<String> letterCombinations(String digits) {
            List<String> result = new ArrayList<>();
            String[] keyboard = {"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};

            letterCombinationsHelper(result, keyboard, digits, 0, "");

            return result;
        }
        private void letterCombinationsHelper(List<String> result, String[] keyboard, String digits, int pointer, String temp){
            if (pointer == digits.length()){
                result.add(new String(temp)); //String no need new
                return;
            }
            int num = Character.getNumericValue(digits.charAt(pointer));
            String key = keyboard[num];
            if (key == ""){
                letterCombinationsHelper(result, keyboard, digits, pointer+1, temp);
            }else {
                for (int i = 0; i < key.length(); i++){
                    letterCombinationsHelper(result, keyboard, digits, pointer+1, temp + key.charAt(i));
                    //temp = temp.substring(0, temp.length() - 1);
                }
            }
        }
    }

    static class bstFromPreorder {

        public TreeNode bstFromPreorder(int[] preorder) {

            TreeNode root = new TreeNode(preorder[0]);
            if (preorder.length == 1){
                return root;
            }
            Stack<TreeNode> helper = new Stack<>();
            TreeNode pointer = root;
            helper.push(root);
            for(int i = 1; i < preorder.length; i++){
                TreeNode temp = new TreeNode(preorder[i]);
                if (preorder[i] < pointer.val){
                    pointer.left = temp;
                    pointer = pointer.left;
                    helper.push(temp);
                }else {

                    while (!helper.empty() && helper.peek().val < preorder[i]){
                        pointer = helper.pop();
                    }
                    pointer.right = temp;
                    pointer = pointer.right;
                    helper.push(temp);
                }
            }
            return root;
        }
    }

    static class shipWithinDays {
        public int shipWithinDays(int[] weights, int D) {

            int sum = 0;

            for (int weight : weights){
                sum += weight;
            }


            int min = 0;    //Should be the min
            int max = sum;  //Shoold be Max(ave, largest);

            int cap = (max - min) / 2;
            while (min < max){


                int weightPointer = 0;
                int day = 0;
                while (day < D && weightPointer < weights.length){
                    int currentWeights = 0;
                    while (currentWeights <= cap && weightPointer < weights.length){
                        currentWeights += weights[weightPointer];
                        weightPointer++;
                    }
                    if (currentWeights > cap){
                        weightPointer--;
                        currentWeights -= weights[weightPointer];
                    }
                    day++;
                }
                if (day == D && weightPointer < weights.length){
                    min = cap+1;
                    cap = min + (max - (cap+1))/2;
                }else{
                    max = cap - 1;
                    cap = min + ((cap-1) - min)/2;
                }
            }

            return cap;
        }
    }

    static class solveNQueens {
        public List<List<String>> solveNQueens(int n) {
            List<List<String>> result = new ArrayList<>();
            char[] dots = new char[n];
            Arrays.fill(dots, '.');
            String line = new String(dots);
            List<String> temp = new ArrayList<>();
            for (int i = 0; i < n; i++){
                temp.add(i, line);
            }
            queenHelper(result, temp, 0, 0, n);

            return result;
        }
        private void queenHelper(List<List<String>> result, List<String> temp, int i, int j, int n){
            if (i >= n){
                i = 0;
                j++;
            }
            if (j >= n){
                result.add(new ArrayList<>(temp));
                System.out.println(temp);
                System.out.println("---------------------------");
                return;
            }
            StringBuilder tempSb = new StringBuilder(temp.get(j));
            tempSb.setCharAt(i, 'Q');
            temp.set(j, tempSb.toString());
            if (validQueen(temp, n)){
                queenHelper(result, temp, i+1, j, n);
            }
            tempSb.setCharAt(i, '.');
            temp.set(j, tempSb.toString());
        }
        private boolean validQueen(List<String> temp, int n){

            for (int i = 0; i < n; i++){
                for (int j = 0; j < n; j++){
                    if (temp.get(j).charAt(i) == 'Q'){
                        //check row
                        for (int i_ = 0; i_ < n; i_++){
                            if (i_ != i && temp.get(j).charAt(i_) == 'Q'){
                                return false;
                            }
                        }
                        //check row
                        //check col
                        for (int j_ = 0; j_ < n; j_++){
                            if (j_ != j && temp.get(j_).charAt(i) == 'Q'){
                                return false;
                            }
                        }
                        //check col
                        //check \
                        int l = 1;
                        while ((i - l >=0 && j - l >=0) || (i + l < n && j - l >=0) || (i - l >=0 && j + l < n) || (i + l <n && j + l < n)){

                            if (i - l >=0 && j - l >=0){
                                if (temp.get(j - l).charAt(i - l) == 'Q'){
                                    return false;
                                }
                            }
                            if (i + l < n && j - l >=0){
                                if (temp.get(j - l).charAt(i + l) == 'Q'){
                                    return false;
                                }
                            }
                            if (i - l >=0 && j + l < n){
                                if (temp.get(j + l).charAt(i - l) == 'Q'){
                                    return false;
                                }
                            }
                            if (i + l <n && j + l < n){
                                if (temp.get(j + l).charAt(i + l) == 'Q'){
                                    return false;
                                }
                            }

                            l++;
                        }
                    }

                }
            }

            return true;
        }
    }


    class subsetsWithDup {
        public List<List<Integer>> subsetsWithDup(int[] nums) {
            List<List<Integer>> result = new ArrayList<>();
            Arrays.sort(nums);
            List<Integer> temp = new ArrayList<>();
            subsetWithDupHelper(result, nums, 0, temp);

            return result;
        }
        private void subsetWithDupHelper(List result, int[] nums, int pointer, List temp){
            if (!result.contains(temp)){
                result.add(new ArrayList<>(temp));
            }
            if (pointer == nums.length){
                return;
            }
            while (pointer < nums.length){
                if (pointer + 1 < nums.length && nums[pointer] == nums[pointer+1]){
                    pointer++;
                    continue;
                }

                temp.add(nums[pointer]);
                pointer++;
                subsetWithDupHelper(result, nums, pointer, temp);
                temp.remove(temp.size()-1);
            }
        }
    }

    static class grayCode {
        public void grayCode(int n){
            StringBuilder s = new StringBuilder();
            for (int i = 0; i < n; i++){
                s.append("0");
            }
            greyCodeHelper(s, 0, n);
        }
        private void greyCodeHelper(StringBuilder s, int pointer, int n){
            if (pointer == n){
                System.out.println(s.toString());
                return;
            }


            greyCodeHelper(s, pointer+1, n);
            if (s.toString().charAt(pointer) == '0'){
                s.replace(pointer, pointer+1, "1");
            }else{
                s.replace(pointer, pointer+1, "0");
            }
            greyCodeHelper(s, pointer+1, n);

        }
    }
    static class combinationSum {
        public List<List<Integer>> combinationSum(int[] candidates, int target) {
            Arrays.sort(candidates);
            List<List<Integer>> result = new ArrayList();
            combinationSumHelper(candidates, target, new ArrayList<Integer>(), result, 0);

            return result;
        }
        private void combinationSumHelper (int[] candidates,int target, List<Integer> temp, List<List<Integer>> result, int i){
            if (target == 0){
                result.add(new ArrayList(temp));
            }
            while (i < candidates.length && candidates[i] <= target){
                temp.add(candidates[i]);
                combinationSumHelper(candidates, target - candidates[i], temp, result , i);
                temp.remove(temp.size() - 1);
                i++;
            }
            return;
        }
    }

    static class trap {
        public int trap(int[] height) {
            int leftpointer = 0;
            int rightpointer = height.length-1;
            int leftMax = height[leftpointer];
            int rightMax = height[rightpointer];
            int water = 0;
            while(leftpointer != rightpointer){
                if(leftMax > height[leftpointer]) water += leftMax - height[leftpointer];
                if(rightMax > height[rightpointer]) water += rightMax - height[rightpointer];
                leftMax = Math.max(leftMax, height[leftpointer]);
                rightMax = Math.max(rightMax, height[rightpointer]);
                if(height[leftpointer] <= height[rightpointer]) leftpointer++;
                else rightpointer--;
            }
            return water;
        }
    }

    static class firstMissingPositive {
        public int firstMissingPositive(int[] nums) {
            for(int i = 0; i < nums.length; i++){
                if(nums[i] > 0 && nums[i]<= nums.length && nums[i] != nums[nums[i] - 1]){
                    swap(nums, i, nums[i] - 1);
                }
            }
            int i = 0;
            while(i < nums.length && nums[i] == i+1){
                i += 1;
            }
            return i+1;
        }
        private void swap(int[] nums, int i, int j){
            int temp = nums[i];
            nums[i] = nums[j];
            nums[j] = temp;
        }
    }
    static class subsets {
        public List<List<Integer>> subsets(int[] nums) {
            List<List<Integer>> result = new ArrayList<>();
            List<Integer> temp = new ArrayList<>();
            subsetsHelper(result, temp, nums, 0);
            return result;
        }
        private void subsetsHelper(List<List<Integer>> result, List<Integer> temp, int[] nums, int i){
            result.add(new ArrayList<Integer>(temp));
            if (i >= nums.length){
                return;
            }
            while (i < nums.length){
                temp.add(nums[i]);
                subsetsHelper(result, temp, nums, ++i);
                if (temp.size() != 0) {
                    temp.remove(temp.size() - 1);
                }
            }
        }
    }

    static class permute {
        public List<List<Integer>> permute(int[] nums) {

            List<List<Integer>> result = new ArrayList<>();
            List<Integer> temp = new ArrayList<>();
            permuteHelper(result, temp, nums);

            return result;
        }
        private void permuteHelper( List<List<Integer>> result, List<Integer> temp, int[] nums){
            if (temp.size() == nums.length){
                result.add(new ArrayList<>(temp));
            }else {
                for (int i = 0; i < nums.length; i++){
                    if (temp.contains(nums[i])) continue;
                    temp.add(nums[i]);
                    permuteHelper(result, temp, nums);
                    temp.remove(temp.size() - 1);
                }
            }
        }
    }

    static private class isValidBST {
        public boolean isValidBST(TreeNode root) {
            if (root == null) return true;
            Stack<TreeNode> stack = new Stack<>();
            TreeNode pre = null;
            while (root != null || !stack.isEmpty()) {
                while (root != null) {
                    stack.push(root);
                    root = root.left;
                }
                root = stack.pop();
                if(pre != null && root.val <= pre.val) return false;
                pre = root;
                root = root.right;
            }
            return true;
        }
    }

}
